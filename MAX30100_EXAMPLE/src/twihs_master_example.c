#include "asf.h"
#include "stdio_serial.h"
#include "conf_board.h"
#include "max30100.h"

#define MAX30100_FIFO_DEPTH                     0x10


/** Global timestamp in milliseconds since start of application */
volatile uint32_t g_ul_ms_ticks = 0;

/**
 *  \brief Handler for System Tick interrupt.
 *
 *  Process System Tick Event
 *  increments the timestamp counter.
 */
void SysTick_Handler(void)
{
	g_ul_ms_ticks++;
}

/**
 *  \brief Configure the Console UART.
 */
static void configure_console(void)
{
	const usart_serial_options_t uart_serial_options = {
		.baudrate = CONF_UART_BAUDRATE,
#ifdef CONF_UART_CHAR_LENGTH
		.charlength = CONF_UART_CHAR_LENGTH,
#endif
		.paritytype = CONF_UART_PARITY,
#ifdef CONF_UART_STOP_BITS
		.stopbits = CONF_UART_STOP_BITS,
#endif
	};

	/* Configure console UART. */
	sysclk_enable_peripheral_clock(CONSOLE_UART_ID);
	stdio_serial_init(CONF_UART, &uart_serial_options);
}

/**
 *  \brief Wait for the given number of milliseconds (using the dwTimeStamp
 *         generated by the SAM microcontrollers' system tick).
 *  \param ul_dly_ticks  Delay to wait for, in milliseconds.
 */
static void mdelay(uint32_t ul_dly_ticks)
{
	uint32_t ul_cur_ticks;

	ul_cur_ticks = g_ul_ms_ticks;
	while ((g_ul_ms_ticks - ul_cur_ticks) < ul_dly_ticks);
}


void max30100_read(uint8_t *buffer, uint32_t bufferlen) {
	twihs_packet_t packet_rx;
	
	/* Configure the data packet to be received */
	packet_rx.chip        = MAX30100_CHIP_ID;
	packet_rx.addr[0]     = 0;
	packet_rx.addr_length = 0;
	packet_rx.buffer      = buffer;
	packet_rx.length      = bufferlen;
	
	/* Get memory from EEPROM*/
	uint32_t ret = twihs_master_read(MAX30100_I2C, &packet_rx);
	
	if (ret != TWIHS_SUCCESS) {
		puts("-E-\tTWI master read packet failed.\r");
		while (1) {
			/* Capture error */
		}
	}
	mdelay(WAIT_TIME);
}

void max30100_write_reg(uint8_t addr, uint8_t *buffer, uint32_t bufferlen) {
	twihs_packet_t packet_tx;

	/* Configure the data packet to be transmitted */
	packet_tx.chip        = MAX30100_CHIP_ID;
	packet_tx.addr[0]     = addr;
	packet_tx.addr_length = 1;
	packet_tx.buffer      = (uint8_t *) buffer;
	packet_tx.length      = bufferlen;

	if (twihs_master_write(MAX30100_I2C, &packet_tx) != TWIHS_SUCCESS) {
		puts("-E-\tTWI master write packet failed.\r");
		while (1) {
			
		}
	}
	
	mdelay(WAIT_TIME);
}


void max30100_write8(uint8_t val) {
	twihs_packet_t packet_tx;

	/* Configure the data packet to be transmitted */
	packet_tx.chip        = MAX30100_CHIP_ID;
	packet_tx.addr_length = 0;
	packet_tx.buffer      = &val;
	packet_tx.length      = 1;

	if (twihs_master_write(MAX30100_I2C, &packet_tx) != TWIHS_SUCCESS) {
		puts("-E-\tTWI master write packet failed.\r");
		while (1) {
			
		}
	}
	
	mdelay(WAIT_TIME);
}

/*
uint8_t max30100_read_reg8(uint8_t addr) {
	uint8_t data;
	
	max30100_read_reg(addr, &data, 1);
	return data;
}
*/

uint8_t max30100_read_reg8(uint8_t addr) {
	twihs_packet_t packet_rx;
	uint8_t buffer[1];
	buffer[0] = 0x00;

	/* Configure the data packet to be received */
	packet_rx.chip        = MAX30100_CHIP_ID;
	packet_rx.addr[0]     = addr;
	packet_rx.addr_length = 1;
	packet_rx.buffer      = &buffer[0];
	packet_rx.length      = 1;
	
	
	/* Get memory from EEPROM*/
	uint32_t ret = twihs_master_read(MAX30100_I2C, &packet_rx);
	
	if (ret != TWIHS_SUCCESS) {
		puts("-E-\tTWI master read packet failed.\r");
		while (1) {
			/* Capture error */
		}
	}
	return  buffer[0];
	mdelay(WAIT_TIME);
}


void max30100_write_reg8(uint8_t addr, uint8_t value) {
	twihs_packet_t packet_tx;

	/* Configure the data packet to be transmitted */
	packet_tx.chip        = MAX30100_CHIP_ID;
	packet_tx.addr[0]     = addr;
	packet_tx.addr_length = 1;
	packet_tx.buffer      = &value;
	packet_tx.length      = 1;

	if (twihs_master_write(MAX30100_I2C, &packet_tx) != TWIHS_SUCCESS) {
		puts("-E-\tTWI master write packet failed.\r");
		while (1) {
			
		}
	}
	
	mdelay(WAIT_TIME);
}


float max30100_read_temperature() {
	  uint8_t v;
	  v = max30100_read_reg8(MAX30100_MODECFG_REG);

	  max30100_write_reg8(MAX30100_MODECFG_REG, v | MAX30100_MODECFG_TEMPEN);

	  while (max30100_read_reg8(MAX30100_MODECFG_REG) & MAX30100_MODECFG_TEMPEN) {
		  mdelay(1);
	  }

	  //uint16_t tempreading = max30100_read_reg16(MAX30100_TEMPDATAINT_REG);
		uint16_t tempreading = 0;
	  uint8_t tfrac = tempreading & 0xF;
	  int8_t tint = tempreading >> 8;

	  float temp = tint;
	  temp += tfrac * 0.0625;
	  return temp;
	  
}

void max30100_setspo2samplerate(max30100_spo2_samplerate_t rate) {
	int previous = max30100_read_reg8(MAX30100_SPO2CFG_REG);
	printf(" read %d \r\n", previous);
	int value;
	if(previous == 0x47) {
		previous = 0x03;
		value = 0x07;
	} else {
		value = (previous & 0xe3) | (rate << 2);
	}
	max30100_write_reg8(MAX30100_SPO2CFG_REG, 0x47);
}

#define MAX30100_SPC_SPO2_HI_RES_EN             (1 << 6)

void max30100_set_highres_mode(uint8_t enabled) {
	uint8_t previous = max30100_read_reg8(MAX30100_SPO2CFG_REG);

	    if (enabled) {
		    //max30100_write_reg8(MAX30100_SPO2CFG_REG, previous | MAX30100_SPC_SPO2_HI_RES_EN);
		    } else {
		    //max30100_write_reg8(MAX30100_SPO2CFG_REG, previous & ~MAX30100_SPC_SPO2_HI_RES_EN);
	    }
	max30100_write_reg8(MAX30100_SPO2CFG_REG, 0x47);
}

void max30100_set_led_pulse_width(max30100_led_pulsewidth_t pw) {
	uint8_t v = max30100_read_reg8(MAX30100_SPO2CFG_REG);
	uint8_t a = (v & 0xfc) | pw;
	max30100_write_reg8(MAX30100_SPO2CFG_REG, 0x47);  // c -> 1100 & 0x03 -> 0 | 
}

void max30100_set_leds_current(uint32_t irLedCurrent, uint32_t redLedCurrent) {
	max30100_write_reg8(MAX30100_LEDCFG_REG, redLedCurrent << 4 | irLedCurrent);
}


void max30100_init() {
	twihs_options_t opt;
	
	/* Configure the options of TWI driver */
	opt.master_clk = sysclk_get_peripheral_hz();
	opt.speed      = TWIHS_CLK;
	opt.smbus = 0;
	
	/* Enable the peripheral clock for TWI */
	pmc_enable_periph_clk(MAX30100_I2C_ID);
	
	if (twihs_master_init(MAX30100_I2C, &opt) != TWIHS_SUCCESS) {
		puts("-E-\tTWI master initialization failed.\r");
		while (1) {
			/* Capture error */
		}
	}
	
	if(max30100_read_reg8(MAX30100_REG_PARTID) != MAX30100_EXPECTED_PARTID) {
		puts("-E-\tRead wrong part ID from MAX30100.\r");
		while(1){}
	}
	
	max30100_write_reg8(MAX30100_MODECFG_REG, MAX30100_MODECFG_HRONLY);
	max30100_set_led_pulse_width(MAX30100_LEDPW_1600US);
	max30100_setspo2samplerate(MAX30100_SPO2SR_100HZ);
	max30100_set_leds_current(MAX30100_LEDCURRENT_50MA, MAX30100_LEDCURRENT_50MA);
	max30100_set_highres_mode(1);
}


void max30100_read_fifo_data()
{
	uint8_t buffer[MAX30100_FIFO_DEPTH*4];
	uint8_t toRead;
	static uint8_t descartes = 0;
	
	toRead = (max30100_read_reg8(MAX30100_FIFO_WRPTR_REG) - max30100_read_reg8(MAX30100_FIFO_RDPTR_REG)) & (MAX30100_FIFO_DEPTH-1);

	if (toRead && descartes > 20) {
		while(1) {
			printf("u did it");
			delay_ms(500);
		}
		
		//max30100_read_reg(MAX30100_FIFO_DATA_REG, buffer, 4 * toRead);

		for (uint8_t i=0 ; i < toRead ; ++i) {
			// Warning: the values are always left-aligned
			uint16_t ir=(uint16_t)((buffer[i*4] << 8) | buffer[i*4 + 1]);
			uint16_t red = (uint16_t)((buffer[i*4 + 2] << 8) | buffer[i*4 + 3]);
			printf("%d %d\r\n", ir, red);
		}
	} else {
		descartes++;
	}
}



/**
 * \brief Application entry point for TWI EEPROM example.
 *
 * \return Unused (ANSI-C compatibility).
 */
int main(void)
{
	/* Initialize the SAM system */
	sysclk_init();

	/* Initialize the board */
	board_init();
	
	configure_console();
	
	/* Configure systick for 1 ms */
	puts("Configure system tick to get 1ms tick period.\r");
	if (SysTick_Config(sysclk_get_cpu_hz() / 1000)) {
		puts("-E- Systick configuration error\r");
		while (1) {
			/* Capture error */
		}
	}
	
	max30100_init();
	puts("MAX30100 detected!");
	
	max30100_write_reg8(MAX30100_MODECFG_REG, MAX30100_MODECFG_HRSP02);
	max30100_set_leds_current(MAX30100_LEDCURRENT_50MA, MAX30100_LEDCURRENT_27_1MA);
	max30100_set_led_pulse_width(MAX30100_LEDPW_1600US);
	max30100_setspo2samplerate(MAX30100_SPO2SR_100HZ);
	max30100_set_highres_mode(1);
	

	while (1) {
		max30100_read_fifo_data();
	}
}
